imports
{
import           UHC.Light.Compiler.Base.API
import qualified UHC.Light.Compiler.CoreRun.API as CR
import qualified UHC.Light.Compiler.CoreRun.API.Internal as CRI
import qualified Data.Vector as V
}

-------------------------------------------------------------------------------
-- CoreRun generation
-------------------------------------------------------------------------------

attr Mod
  syn crmod :: {CR.Mod}

sem Mod
    | Mod  lhs    .   crmod   =   CR.mkModWithMetas (mkHNm "Main") 
                                                    Nothing 
                                                    @stksize 
                                                    @meta.crmetal -- <- meta information
                                                    (V.fromList @binds.crbindl)
                                                    @main.crexp

attr Meta MetaL
  syn crmetal use {++} {[]} :: {[CR.Meta]}

attr MetaDataCon MetaDataConL
  syn crdataconl use {++} {[]} :: {[CR.DataCon]}

sem Meta
  | MetaDataType lhs.crmetal = [ CR.mkMetaDataType (mkHNm @name) @dcons.crdataconl ]

sem MetaDataCon
  | MetaDataCon lhs.crdataconl = [ CR.mkMetaDataCon (mkHNm @name) @tag ]

attr SExpL SExp
  syn crsexpl use {++} {[]} :: {[CR.SExp]}

sem SExp
  | Int  lhs    .   crsexpl =   [CR.mkInt' @i]
  | Var  lhs    .   crsexpl =   [CR.mkVar' $ head @x.crrefl]

attr Exp
  syn crexp :: {CR.Exp}
attr Exp ExpL
  syn crexpl use {++} {[]} :: {[CR.Exp]}

sem Exp
  | SExp loc    .   crexp   =   CR.mkExp (head @sexp.crsexpl)
  | Lam  loc    .   crexp   =   CR.mkLam (length @args.crrefl) @stksize @body.crexp
  | App  loc    .   crexp   =   CR.mkApp @func.crexp @args.crsexpl
  | Prim loc    .   crexp   =   CR.mkFFI @func       @args.crsexpl
  | Node loc    .   crexp   =   CR.mkTup @tag        @args.crsexpl
  | Case loc    .   crexp   =   CR.mkCase (head @sexp.crsexpl) @alts.crexpl
  | Let  loc    .   crexp   =   CR.mkLet @lhs.stkoff @bind.crbindl @body.crexp
  | Dbg  loc    .   crexp   =   CR.mkDbg @info
  | Eval loc    .   crexp   =   CR.mkEval @thunk.crexp
  

sem Exp
  | * 	 lhs	.	crexpl	=	[@crexp]

attr BindL Bind
  syn crbindl use {++} {[]} :: {[CR.Bind]}

sem Bind
  | Bind lhs    .   crbindl =   [@xexp.crexp]

attr RefL Ref
  syn crrefl use {++} {[]} :: {[CR.RRef]}

sem Ref
  | Glob  lhs   .   crrefl  =   [CR.mkModRef @offset]
  | Loc   lhs   .   crrefl  =   [CR.mkLocDifRef @levdiff @offset]
  | Tag   lhs   .   crrefl  =   map CRI.RRef_Tag @ref.crrefl


-------------------------------------------------------------------------------
-- Stack offset for Let
-------------------------------------------------------------------------------

attr Exp ExpL
  inh stkoff  :: {Int}
  inh stksize :: {Int}
attr Bind BindL
  chn stkoff  :: {Int}
  inh stksize :: {Int}

sem Mod
  | Mod  loc    .   stksize =   length @binds.crbindl + length @meta.crmetal + 2 -- for main and main exp
         binds  .   stkoff  =   0
         binds  .   stksize =   length @meta.crmetal + 2 
         main   .   stkoff  =   @binds.stkoff
         main   .   stksize =   @stksize

sem Bind
  | Bind xexp   .   stkoff  =   0
         xexp   .   stksize =   @lhs.stksize
         lhs    .   stkoff  =   @lhs.stkoff + 1

sem Exp
  | Lam  body   .   stkoff  =   length @args.crrefl
         loc    .   stksize =   @lhs.stksize + length @args.crrefl
         body   .   stksize =   @stksize

