-------------------------------------------------------------------------------
-- Attr grammar
-------------------------------------------------------------------------------
imports
{
import qualified CCO.Core.AG as CR
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import qualified Data.Set as Set
import Debug.Trace
}

{
-- | An absolute reference to a variable declaration. In contrast to 'CR.Ref',
-- @DeclLoc@ takes the absolute lexical level counted from the root instead of
-- an relative level counted from the current one.
data DeclRef
  = DeclLoc { declLocLevel :: Int, declLocOffset :: Int}
  | DeclGlob { declGlobOffset :: Int }
  | DeclField { declFieldBase :: DeclRef, declFieldIdx :: Int }
  deriving (Eq, Ord, Show, Read)

type Environment = Map.Map String DeclRef

type GlobalBinds = Map.Map Int CR.Exp

type TagMap = Map.Map String Int
}

attr Mod
  syn mod                  :: {CR.Mod}

sem Mod
  | Mod loc.modBinds = map (\(o,e) -> CR.Bind (CR.Glob o) e) $ Map.toAscList (@dataTypes.globalBinds `Map.union` @tm.globalBinds)
        lhs.mod      = CR.Mod @tm.exp @dataTypes.metal @loc.modBinds
        -- pass inherited attributes
        dataTypes.globalOffset = 0
        dataTypes.env          = Map.empty
        dataTypes.names        = Set.empty
        tm.level        = 0
        tm.globalScope  = True
        tm.globalOffset = length @dataTypes.globalBinds
        tm.env          = @dataTypes.env
        tm.offset       = 0
        tm.forceEval    = True
        tm.conTags      = @dataTypes.conTags

-- TODO: for error messages add SourcePos for datatypes and constructors in Pos.AG 
--       add debug information, the corerun starts to be a bit unclear with the allocs without the appropriate constructor in comments..

attr DataTyL DataTy DataTy_
  -- for storing all the names of the datatypes and checking if they are unique
  chn names                                     :: {Set.Set Name}
  -- a mapping of all constructors to global bindings
  syn metal       use {++}          {[]}        :: {CR.MetaL}  

attr DataConL DataCon DataCon_
  -- a mapping of all constructors to global bindings
  inh conIndex                                  :: Int
  syn metaConl    use {++}          {[]}        :: {CR.MetaDataConL}  

attr DataConL DataCon DataCon_ DataTyL DataTy DataTy_
  chn globalOffset                              :: Int
  -- a map from the constructor names to their assigned tags
  syn conTags use {Map.union} {Map.empty}       :: TagMap
  syn globalBinds use {`Map.union`} {Map.empty} :: {GlobalBinds}
  chn env                                       :: {Environment}

sem DataTy_
  | DataTy_ loc   . uniqueDataTy = uniqueDataType @name @lhs.names
            lhs   . names        = Set.insert @name @lhs.names
            lhs   . metal        = [ CR.MetaDataType @uniqueDataTy @dcons.metaConl ]
            dcons . conIndex     = 0

sem DataConL
  | Cons tl . conIndex     = @lhs.conIndex     + 1
         tl . globalOffset = @lhs.globalOffset + 1

sem DataCon_
  | DataCon_ -- The arguments to the node from left to right are gathered from the outermost
             -- to the innermost lambda expression. Because of laziness, each function-lambda
             -- is followed by a thunk-lambda.
             loc . nodeArgs    = [ CR.Var $ CR.Loc (2 * i + 1) 0 | i <- [@arity - 1, @arity - 2 .. 0] ]
             loc . node        = mkThunk $ iterateFun @arity (CR.Lam [CR.Loc 0 0] . mkThunk)
                                                             (CR.Node @lhs.conIndex @nodeArgs)
             lhs . globalBinds = Map.insert @lhs.globalOffset @node Map.empty
             loc . uniqueCon   = uniqueConstructor @name @lhs.env
             lhs . env         = Map.insert @uniqueCon (DeclGlob @lhs.globalOffset) @lhs.env
             lhs . metaConl    = [ CR.MetaDataCon @name @lhs.conIndex ]
             lhs . conTags     = Map.singleton @name @lhs.conIndex

attr Tm Tm_
  -- the generated expression
  syn exp                  :: {CR.Exp}

attr Tm Tm_ TmL Alt AltL
  -- a mapping of all variables in scope
  inh env                  :: {Environment}
  -- the absolute lexical level (counted from the top, first level is 0)
  -- we are currently in.
  inh level                :: {Int}
  -- let bindings at the root of the AST are translated to global bindings
  -- and handled by HMToCR
  inh globalScope          :: Bool
  inh globalOffset         :: Int
  syn globalBinds use {`Map.union`} {Map.empty} :: GlobalBinds
  -- local stack offset
  inh offset               :: {Int}
  inh forceEval            :: {Bool}
  -- a map from the constructor names to their assigned tags
  inh conTags              :: TagMap

attr TmL
  syn expL use {++} {[]}   :: {[CR.Exp]}

attr Alt AltL
  syn altMap use {Map.union} {Map.empty} :: {Map.Map Int CR.Exp}
  inh scrutRef :: {DeclRef}

sem TmL
  | Cons lhs.expL = @hd.exp : @tl.expL

sem Tm_
  | Nat lhs.exp    = CR.SExp (CR.Int @i)
        --lhs.offset = @lhs.offset + 1

  | Var lhs.exp    = optForceEval @lhs.forceEval $ 
                      CR.SExp (CR.Var (varToRef @lhs.pos @lhs.level @lhs.env @x))
        --lhs.offset = @lhs.offset + 1

  | Lam lhs.exp    = CR.Lam [CR.Loc 0 0] $ mkThunk @t1.exp
        loc.ref    = DeclLoc (@lhs.level + 1) 0
        t1.env     = Map.insert @x @ref @lhs.env
        t1.level   = @lhs.level + 2
        t1.offset  = 0
        t1.globalScope = False
        t1.forceEval = True
        
  | Prim  loc.arity = length @args.expL
          loc.slots = [@lhs.offset .. @lhs.offset + @arity - 1]
          loc.argSlots = zip @slots @args.expL
          loc.argRefs  = map (CR.Var . CR.Loc 0) @slots
          args.forceEval = True
          lhs.exp = foldr (\(sl,arg) -> CR.Let (CR.Bind (CR.Loc 0 sl) arg)) (CR.Prim @fn @argRefs) @argSlots

  | App lhs.exp   = optForceEval @lhs.forceEval $ CR.App @t1.exp [expToSExp @t2.exp]
        t1.offset = notRequired $ @lhs.offset -- always takes one argument
        t2.offset = notRequired $ @lhs.offset
        t1.forceEval = True
        t2.forceEval = False
       
  | Let loc.isGlobal = @lhs.globalScope -- are we in global scope? TODO: Better way of determining this
        -- make a thunk
        loc.thunk  = mkThunk @t1.exp
        t1.forceEval = True
        t1.level   = @lhs.level + 1
        t1.offset  = 0
        -- create binding
        lhs.exp    =
          if @loc.isGlobal
              -- binding is lifted to global scope
              then @t2.exp
              -- local binding on the stack (in current level)
              else CR.Let (CR.Bind (CR.Loc 0 @lhs.offset) @thunk) @t2.exp
        -- next free slot for a global binding
        t2.globalOffset = if @loc.isGlobal 
                            then @lhs.globalOffset + 1 
                            else @lhs.globalOffset
        -- create ref depending on where expression is bound
        loc.ref    =
          if @loc.isGlobal
            then DeclGlob @lhs.globalOffset
            else DeclLoc @lhs.level @lhs.offset
        -- possibly update global bindings
        lhs.globalBinds =
          if @loc.isGlobal
            then Map.insert @lhs.globalOffset @thunk @t2.globalBinds
            else @t2.globalBinds
        -- provide binding to body and the bound expression (to allow recursion)
        loc.newEnv = Map.insert @x @ref @lhs.env
        t1.env     = @loc.newEnv
        t2.env     = @loc.newEnv
        -- thread offset through computation
        t2.offset  = if @loc.isGlobal 
                            then @lhs.offset
                            else @lhs.offset + 1
        --lhs.offset = @t2.offset
        t1.globalScope = False
        
   | If loc.thunkValRef = CR.Loc 0 @lhs.offset
        lhs.exp    = CR.Let (CR.Bind @thunkValRef (CR.Eval @cond.exp)) $
                        CR.Case (CR.Var $ CR.Tag @thunkValRef) [@t2.exp, @t1.exp]
        --lhs.offset = @lhs.offset + 1
        cond.forceEval = False
        --t1.level   = @lhs.level + 1
        t1.offset  = notRequired $ @lhs.offset + 1
        t2.offset  = notRequired $ @lhs.offset + 1
        t1.globalScope   = False
        t2.globalScope   = False
        cond.globalScope = False
   | Case
        -- evaluate the scrutinee in a local binding
        loc.thunkValRef = CR.Loc 0 @lhs.offset
        -- the alternatives are added in ascending order by tag (using 'Map.elems')
        lhs.exp    = CR.Let (CR.Bind @thunkValRef (CR.Eval @scrut.exp)) $
                        CR.Case (CR.Var $ CR.Tag @thunkValRef) (Map.elems $ @alts.altMap)
        scrut.forceEval = False
        -- we bound the scrutinee, so + 1
        -- not that all alternatives share the same offset, 
        -- because only one of them will eventually be executed
        alts.offset  = @lhs.offset + 1
        alts.globalScope   = False
        alts.scrutRef = DeclLoc @lhs.level @lhs.offset
        scrut.globalScope = False

sem Alt
  -- The alternative is indexed by the constructor tag in the synthesized attribute
  | Alt lhs.altMap  = Map.singleton (lookupConTag @con @lhs.conTags) @tm.exp
        -- arity of the constructor (not checked)
        loc.arity   = length @vars
        -- build references to fields of the scrutinee
        loc.argRefs = map (DeclField @lhs.scrutRef) [0 .. @arity - 1]
        loc.argEnv  = Map.fromList $ zip @vars @argRefs
        -- bind pattern variables to the fields
        tm.env      = Map.union @lhs.env @loc.argEnv

{
expToSExp :: CR.Exp -> CR.SExp
expToSExp (CR.SExp se) = se
expToSExp _            = error "Exp not a SExp"

varToRef :: SourcePos -> Int -> Environment -> Var -> CR.Ref
varToRef pos currentLevel env x = case Map.lookup x env of
    Just ref -> convertRef ref
    Nothing -> error $ "Variable " ++ x ++ " not found (" ++ describeSourcePos pos ++ ")"
  where
    convertRef r = case r of
      DeclLoc bindLevel offset -> CR.Loc (currentLevel - bindLevel) offset
      DeclGlob offset          -> CR.Glob offset
      DeclField base idx       -> CR.Field (convertRef base) idx

mkThunk :: CR.Exp -> CR.Exp
mkThunk = CR.Lam []

optForceEval :: Bool -> CR.Exp -> CR.Exp
optForceEval True x = CR.Eval x
optForceEval False x = x

notRequired :: a -> b
notRequired _ = error "has the program been passed to 'hm-to-anf'?"

uniqueDataType :: Name -> Set.Set Name -> Name
uniqueDataType name names = case Set.member name names of
    True  -> error $ "Datatype \"" ++ name ++ "\" is not unique"
    False -> name

uniqueConstructor :: Name -> Environment -> Name
uniqueConstructor name env = case Map.member name env of
    True  -> error $ "Data Constructor \"" ++ name ++ "\" is not unique"
    False -> name

-- | Looks up the tag of a constructor in the map, and raises an error otherwise.
lookupConTag :: Name -> TagMap -> Int
lookupConTag name = fromMaybe err . Map.lookup name where
  err = error $ "Constructor '" ++ name ++ " not found." 

-- | @iterateFun n f x@ applies the function @f@ @n@ times on @x@.
iterateFun :: Int -> (a -> a) -> a -> a
iterateFun n f x | n <= 0    = x
                 | otherwise = iterateFun (n-1) f (f x) 
}
