-------------------------------------------------------------------------------
-- Attr grammar
-------------------------------------------------------------------------------
imports
{
import qualified CCO.Core.AG as CR
import qualified Data.Map as Map

import Debug.Trace
}

{
-- | An absolute reference to a variable declaration. In contrast to 'CR.Ref',
-- @DeclLoc@ takes the absolute lexical level counted from the root instead of
-- an relative level counted from the current one.
data DeclRef
  = DeclLoc { declLocLevel :: Int, declLocOffset :: Int}
  | DeclGlob { declGlobOffset :: Int }
  deriving (Eq, Ord, Show, Read)

type Environment = Map.Map Var DeclRef
}

data HMToCR
  | HMToCR root :: Tm

attr HMToCR
  syn mod                  :: {CR.Mod}

sem HMToCR
  | HMToCR loc.modBinds = map (\(o,e) -> CR.Bind (CR.Glob o) e) $ Map.toAscList @root.globalBinds
           lhs.mod           = CR.Mod @root.exp @loc.modBinds
           -- pass inherited attributes
           root.level        = 0
           root.globalBinds  = Map.empty
           root.env          = Map.empty
           root.offset       = 0

attr Tm Tm_
  -- a mapping of all variables in scope
  inh env                  :: {Environment}
  -- the absolute lexical level (counted from the top, first level is 0)
  -- we are currently in.
  inh level                :: {Int}
  -- let bindings at the root of the AST are translated to global bindings
  -- and handled by HMToCR
  syn globalBinds          :: {Map.Map Int CR.Exp}
  inh globalBinds          :: {Map.Map Int CR.Exp}
  -- local stack offset
  inh offset               :: {Int}
  --syn offset               :: {Int}
  -- the generated expression
  syn exp                  :: {CR.Exp}

sem Tm_
  | Nat lhs.exp    = CR.SExp (CR.Int @i)
        --lhs.offset = @lhs.offset + 1

  | Var lhs.exp    = CR.SExp (CR.Var (varToRef @lhs.pos @lhs.level @lhs.env @x))
        --lhs.offset = @lhs.offset + 1

  | Lam lhs.exp    = CR.Lam [CR.Loc 0 0] @t1.exp
        --lhs.offset = @lhs.offset + 1
        loc.ref    = DeclLoc (@lhs.level + 1) 0
        t1.env     = Map.insert @x @ref @lhs.env
        t1.level   = @lhs.level + 1
        t1.offset  = 1 -- always takes one argument
        
  | Prim lhs.exp = CR.Prim @fn []

  | App lhs.exp   = case @t1.exp of
                      CR.Prim fn args -> CR.Prim fn (args ++ [expToSExp @t2.exp])
                      other           -> CR.App other [expToSExp @t2.exp]
        t1.offset = @lhs.offset -- always takes one argument
        t2.offset = @lhs.offset
       
  | Let loc.isGlobal = @lhs.level == 0 -- are we in global scope? TODO: Better way of determining this
        loc.thunk  = case @t1.exp of
                      CR.Lam _ _ -> @t1.exp
                      _ -> CR.Lam [] @t1.exp
        lhs.exp    =
          if @loc.isGlobal
              -- binding is lifted to global scope
              then @t2.exp
              -- local binding on the stack (in current level)
              else CR.Let (CR.Bind (CR.Loc 0 @lhs.offset) @thunk) @t2.exp
        -- next free slot for a global binding
        loc.globalOffset = Map.size @lhs.globalBinds
        -- create ref depending on where expression is bound
        loc.ref    =
          if @loc.isGlobal
            then DeclGlob @globalOffset
            else DeclLoc @lhs.level @lhs.offset
        -- possibly update global bindings
        loc.newGlobalBinds =
          if @loc.isGlobal
            then Map.insert @globalOffset @thunk @lhs.globalBinds
            else @lhs.globalBinds
        t1.globalBinds  = @loc.newGlobalBinds
        t2.globalBinds  = @t1.globalBinds
        lhs.globalBinds = @t2.globalBinds
        -- provide binding to body and the bound expression (to allow recursion)
        loc.newEnv = Map.insert @x @ref @lhs.env
        t1.env     = @loc.newEnv
        t2.env     = @loc.newEnv
        -- thread offset through computation
        t1.offset  = @lhs.offset
        t2.offset  = @lhs.offset + 1
        --lhs.offset = @t2.offset
        
   | If lhs.exp    = CR.Case (expToSExp @cond.exp) [@t2.exp, @t1.exp]
        --lhs.offset = @lhs.offset + 1
        t1.level   = @lhs.level + 1
        t1.offset  = @lhs.offset 
        t2.offset  = @lhs.offset


{
expToSExp :: CR.Exp -> CR.SExp
expToSExp (CR.SExp se) = se
expToSExp _            = error "Exp not a SExp"

varToRef :: SourcePos -> Int -> Environment -> Var -> CR.Ref
varToRef pos currentLevel env x = case Map.lookup x env of
    Just (DeclLoc bindLevel offset) -> CR.Loc (currentLevel - bindLevel) offset
    Just (DeclGlob offset) -> CR.Glob offset
    Nothing -> error $ "Variable " ++ x ++ " not found (" ++ describeSourcePos pos ++ ")"
}
