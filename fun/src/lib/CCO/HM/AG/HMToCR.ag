-------------------------------------------------------------------------------
-- Attr grammar
-------------------------------------------------------------------------------
imports
{
import qualified CCO.Core.AG as CR
import qualified Data.Map as Map
import qualified Data.Set as Set
import Debug.Trace
}

{
-- | An absolute reference to a variable declaration. In contrast to 'CR.Ref',
-- @DeclLoc@ takes the absolute lexical level counted from the root instead of
-- an relative level counted from the current one.
data DeclRef
  = DeclLoc { declLocLevel :: Int, declLocOffset :: Int}
  | DeclGlob { declGlobOffset :: Int }
  | DeclTag { declRef :: DeclRef }
  deriving (Eq, Ord, Show, Read)

type Environment = Map.Map String DeclRef

type GlobalBinds = Map.Map Int CR.Exp
}

attr Mod
  syn mod                  :: {CR.Mod}

sem Mod
  | Mod loc.modBinds = map (\(o,e) -> CR.Bind (CR.Glob o) e) $ Map.toAscList (@dataTypes.globalBinds `Map.union` @tm.globalBinds)
        lhs.mod      = CR.Mod @tm.exp @dataTypes.metal @loc.modBinds
        -- pass inherited attributes
        dataTypes.globalOffset = 0
        dataTypes.env          = Map.empty
        dataTypes.names        = Set.empty
        tm.level        = 0
        tm.globalScope  = True
        tm.globalOffset = length @dataTypes.globalBinds
        tm.env          = @dataTypes.env
        tm.offset       = 0
        tm.forceEval    = True

-- TODO: for error messages add SourcePos for datatypes and constructors in Pos.AG 
--       add debug information, the corerun starts to be a bit unclear with the allocs without the appropriate constructor in comments..

attr DataTyL DataTy DataTy_
  chn globalOffset                              :: Int
  -- for storing all the names of the datatypes and checking if they are unique
  chn names                                     :: {Set.Set Name}
  -- a mapping of all constructors to global bindings
  chn env                                       :: {Environment}
  syn globalBinds use {`Map.union`} {Map.empty} :: {GlobalBinds}
  syn metal       use {++}          {[]}        :: {CR.MetaL}  

attr DataConL DataCon DataCon_
  chn globalOffset                              :: Int
  -- a mapping of all constructors to global bindings
  chn env                                       :: {Environment}
  inh conIndex                                  :: Int
  syn globalBinds use {`Map.union`} {Map.empty} :: {GlobalBinds}
  syn metaConl    use {++}          {[]}        :: {CR.MetaDataConL}  
  
sem DataTy_
  | DataTy_ loc   . uniqueDataTy = uniqueDataType @name @lhs.names
            lhs   . names        = Set.insert @name @lhs.names
            lhs   . metal        = [ CR.MetaDataType @uniqueDataTy @dcons.metaConl ]
            dcons . conIndex     = 0

sem DataConL
  | Cons tl . conIndex     = @lhs.conIndex     + 1
         tl . globalOffset = @lhs.globalOffset + 1

sem DataCon_
  | DataCon_ loc . argRefs     = map (CR.Loc 0) [0 .. @arity - 1]
             loc . varRefs     = map CR.Var     @argRefs
             loc . node        = 
                if @arity == 0
                    then CR.Node @lhs.conIndex []
                    else CR.Node @lhs.conIndex @varRefs
             lhs . globalBinds = 
                if @arity == 0 
                    then Map.insert @lhs.globalOffset @node                   Map.empty
                    else Map.insert @lhs.globalOffset (CR.Lam @argRefs @node) Map.empty
             loc . uniqueCon   = uniqueConstructor @name @lhs.env
             lhs . env         = Map.insert @uniqueCon (DeclTag $ DeclGlob @lhs.globalOffset) @lhs.env
             lhs . metaConl    = [ CR.MetaDataCon @name @lhs.conIndex ]

attr Tm Tm_
  syn exp                  :: {CR.Exp}

attr Tm Tm_ TmL
  -- a mapping of all variables in scope
  inh env                  :: {Environment}
  -- the absolute lexical level (counted from the top, first level is 0)
  -- we are currently in.
  inh level                :: {Int}
  -- let bindings at the root of the AST are translated to global bindings
  -- and handled by HMToCR
  inh globalScope          :: Bool
  inh globalOffset         :: Int
  syn globalBinds use {`Map.union`} {Map.empty} :: GlobalBinds
  -- local stack offset
  inh offset               :: {Int}
  inh forceEval            :: {Bool}
  --syn offset               :: {Int}
  -- the generated expression

attr TmL
  syn expL use {++} {[]}   :: {[CR.Exp]}

sem TmL
  | Cons lhs.expL = @hd.exp : @tl.expL

sem Tm_
  | Nat lhs.exp    = CR.SExp (CR.Int @i)
        --lhs.offset = @lhs.offset + 1

  | Var lhs.exp    = optForceEval @lhs.forceEval $ CR.SExp (CR.Var (varToRef @lhs.pos @lhs.level @lhs.env @x))
        --lhs.offset = @lhs.offset + 1

  | Lam lhs.exp    = CR.Lam [CR.Loc 0 0] $ mkThunk @t1.exp
        loc.ref    = DeclLoc (@lhs.level + 1) 0
        t1.env     = Map.insert @x @ref @lhs.env
        t1.level   = @lhs.level + 2
        t1.offset  = 0
        t1.globalScope = False
        t1.forceEval = True
        
  | Prim  loc.arity = length @args.expL
          loc.slots = [@lhs.offset .. @lhs.offset + @arity - 1]
          loc.argSlots = zip @slots @args.expL
          loc.argRefs  = map (CR.Var . CR.Loc 0) @slots
          args.forceEval = True
          lhs.exp = foldr (\(sl,arg) -> CR.Let (CR.Bind (CR.Loc 0 sl) arg)) (CR.Prim @fn @argRefs) @argSlots

  | App lhs.exp   = optForceEval @lhs.forceEval $ CR.App @t1.exp [expToSExp @t2.exp]
        t1.offset = notRequired $ @lhs.offset -- always takes one argument
        t2.offset = notRequired $ @lhs.offset
        t1.forceEval = True
        t2.forceEval = False
       
  | Let loc.isGlobal = @lhs.globalScope -- are we in global scope? TODO: Better way of determining this
        -- make a thunk
        loc.thunk  = mkThunk @t1.exp
        t1.forceEval = True
        t1.level   = @lhs.level + 1
        t1.offset  = 0
        -- create binding
        lhs.exp    =
          if @loc.isGlobal
              -- binding is lifted to global scope
              then @t2.exp
              -- local binding on the stack (in current level)
              else CR.Let (CR.Bind (CR.Loc 0 @lhs.offset) @thunk) @t2.exp
        -- next free slot for a global binding
        t2.globalOffset = if @loc.isGlobal 
                            then @lhs.globalOffset + 1 
                            else @lhs.globalOffset
        -- create ref depending on where expression is bound
        loc.ref    =
          if @loc.isGlobal
            then DeclGlob @lhs.globalOffset
            else DeclLoc @lhs.level @lhs.offset
        -- possibly update global bindings
        lhs.globalBinds =
          if @loc.isGlobal
            then Map.insert @lhs.globalOffset @thunk @t2.globalBinds
            else @t2.globalBinds
        -- provide binding to body and the bound expression (to allow recursion)
        loc.newEnv = Map.insert @x @ref @lhs.env
        t1.env     = @loc.newEnv
        t2.env     = @loc.newEnv
        -- thread offset through computation
        t2.offset  = if @loc.isGlobal 
                            then @lhs.offset
                            else @lhs.offset + 1
        --lhs.offset = @t2.offset
        t1.globalScope = False
        
   | If loc.thunkValRef = CR.Loc 0 @lhs.offset
        lhs.exp    = CR.Let (CR.Bind @thunkValRef (CR.Eval @cond.exp)) $
                        CR.Case (CR.Var $ CR.Tag @thunkValRef) [@t2.exp, @t1.exp]
        --lhs.offset = @lhs.offset + 1
        cond.forceEval = False
        --t1.level   = @lhs.level + 1
        t1.offset  = notRequired $ @lhs.offset + 1
        t2.offset  = notRequired $ @lhs.offset + 1
        t1.globalScope   = False
        t2.globalScope   = False
        cond.globalScope = False

{
expToSExp :: CR.Exp -> CR.SExp
expToSExp (CR.SExp se) = se
expToSExp _            = error "Exp not a SExp"

varToRef :: SourcePos -> Int -> Environment -> Var -> CR.Ref
varToRef pos currentLevel env x = case Map.lookup x env of
    Just (DeclLoc bindLevel offset) -> CR.Loc (currentLevel - bindLevel) offset
    Just (DeclGlob offset)          -> CR.Glob offset
    Just (DeclTag ref)              -> CR.Tag $ case ref of 
                                                  DeclLoc _ _      -> error "Local declaration of constructor"
                                                  DeclGlob offset  -> CR.Glob offset
                                                  DeclTag _        -> error "Tag within a tag"
    Nothing -> error $ "Variable " ++ x ++ " not found (" ++ describeSourcePos pos ++ ")"

mkThunk :: CR.Exp -> CR.Exp
mkThunk = CR.Lam []

optForceEval :: Bool -> CR.Exp -> CR.Exp
optForceEval True x = CR.Eval x
optForceEval False x = x

notRequired :: a -> b
notRequired _ = error "has the program been passed to 'hm-to-anf'?"

uniqueDataType :: Name -> Set.Set Name -> Name
uniqueDataType name names = case Set.member name names of
    True  -> error $ "Datatype \"" ++ name ++ "\" is not unique"
    False -> name

uniqueConstructor :: Name -> Environment -> Name
uniqueConstructor name env = case Map.member name env of
    True  -> error $ "Data Constructor \"" ++ name ++ "\" is not unique"
    False -> name
}
