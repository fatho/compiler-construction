-------------------------------------------------------------------------------
-- Attr grammar
-------------------------------------------------------------------------------
imports
{
import qualified CCO.Core.AG as CR
import qualified Data.Map as Map

import Debug.Trace
}

{
-- | An absolute reference to a variable declaration. In contrast to 'CR.Ref',
-- @DeclLoc@ takes the absolute lexical level counted from the root instead of
-- an relative level counted from the current one.
data DeclRef
  = DeclLoc { declLocLevel :: Int, declLocOffset :: Int}
  | DeclGlob { declGlobOffset :: Int }
  deriving (Eq, Ord, Show, Read)

type Environment = Map.Map Var DeclRef

boolMeta :: CR.Meta
boolMeta = CR.MetaDataType "Bool" [CR.MetaDataCon "False" 0, CR.MetaDataCon "True" 1]
}

attr Mod
  syn mod                  :: {CR.Mod}

sem Mod
  | Mod loc.modBinds = map (\(o,e) -> CR.Bind (CR.Glob o) e) $ Map.toAscList @tm.globalBinds
        lhs.mod      = CR.Mod @tm.exp @dataTypes.metal @loc.modBinds
        -- pass inherited attributes
        tm.level        = 0
        tm.globalScope  = True
        tm.globalOffset = 0
        tm.env          = Map.empty
        tm.offset       = 0
        tm.forceEval    = True

attr DataTyL DataTy DataTy_
  syn metal use {++} {[]} :: {CR.MetaL}

attr DataConL DataCon DataCon_
  inh conIndex :: Int
  syn metaConl use {++} {[]} :: {CR.MetaDataConL}
  
sem DataTy_
  | DataTy_ lhs . metal = [ CR.MetaDataType @name @dcons.metaConl ]
           dcons . conIndex = 0

sem DataConL
  | Cons tl . conIndex = @lhs.conIndex + 1

sem DataCon_
  | DataCon_ lhs . metaConl = [ CR.MetaDataCon @name @lhs.conIndex ]

attr Tm Tm_
  syn exp                  :: {CR.Exp}

attr Tm Tm_ TmL
  -- a mapping of all variables in scope
  inh env                  :: {Environment}
  -- the absolute lexical level (counted from the top, first level is 0)
  -- we are currently in.
  inh level                :: {Int}
  -- let bindings at the root of the AST are translated to global bindings
  -- and handled by HMToCR
  inh globalScope          :: Bool
  inh globalOffset         :: Int
  syn globalBinds use {`Map.union`} {Map.empty} :: {Map.Map Int CR.Exp}
  -- local stack offset
  inh offset               :: {Int}
  inh forceEval            :: {Bool}
  --syn offset               :: {Int}
  -- the generated expression

attr TmL
  syn expL use {++} {[]}   :: {[CR.Exp]}

sem TmL
  | Cons lhs.expL = @hd.exp : @tl.expL

sem Tm_
  | Nat lhs.exp    = CR.SExp (CR.Int @i)
        --lhs.offset = @lhs.offset + 1

  | Var lhs.exp    = optForceEval @lhs.forceEval $ CR.SExp (CR.Var (varToRef @lhs.pos @lhs.level @lhs.env @x))
        --lhs.offset = @lhs.offset + 1

  | Lam lhs.exp    = CR.Lam [CR.Loc 0 0] $ mkThunk @t1.exp
        loc.ref    = DeclLoc (@lhs.level + 1) 0
        t1.env     = Map.insert @x @ref @lhs.env
        t1.level   = @lhs.level + 2
        t1.offset  = 0
        t1.globalScope = False
        t1.forceEval = True
        
  | Prim  loc.arity = length @args.expL
          loc.slots = [@lhs.offset .. @lhs.offset + @arity - 1]
          loc.argSlots = zip @slots @args.expL
          loc.argRefs  = map (CR.Var . CR.Loc 0) @slots
          args.forceEval = True
          lhs.exp = foldr (\(sl,arg) -> CR.Let (CR.Bind (CR.Loc 0 sl) arg)) (CR.Prim @fn @argRefs) @argSlots

  | App lhs.exp   = optForceEval @lhs.forceEval $ CR.App @t1.exp [expToSExp @t2.exp]
        t1.offset = notRequired $ @lhs.offset -- always takes one argument
        t2.offset = notRequired $ @lhs.offset
        t1.forceEval = True
        t2.forceEval = False
       
  | Let loc.isGlobal = @lhs.globalScope -- are we in global scope? TODO: Better way of determining this
        -- make a thunk
        loc.thunk  = mkThunk @t1.exp
        t1.forceEval = True
        t1.level   = @lhs.level + 1
        t1.offset  = 0
        -- create binding
        lhs.exp    =
          if @loc.isGlobal
              -- binding is lifted to global scope
              then @t2.exp
              -- local binding on the stack (in current level)
              else CR.Let (CR.Bind (CR.Loc 0 @lhs.offset) @thunk) @t2.exp
        -- next free slot for a global binding
        t2.globalOffset = if @loc.isGlobal 
                            then @lhs.globalOffset + 1 
                            else @lhs.globalOffset
        -- create ref depending on where expression is bound
        loc.ref    =
          if @loc.isGlobal
            then DeclGlob @lhs.globalOffset
            else DeclLoc @lhs.level @lhs.offset
        -- possibly update global bindings
        lhs.globalBinds =
          if @loc.isGlobal
            then Map.insert @lhs.globalOffset @thunk @t2.globalBinds
            else @t2.globalBinds
        -- provide binding to body and the bound expression (to allow recursion)
        loc.newEnv = Map.insert @x @ref @lhs.env
        t1.env     = @loc.newEnv
        t2.env     = @loc.newEnv
        -- thread offset through computation
        t2.offset  = if @loc.isGlobal 
                            then @lhs.offset
                            else @lhs.offset + 1
        --lhs.offset = @t2.offset
        t1.globalScope = False
        
   | If loc.thunkValRef = CR.Loc 0 @lhs.offset
        lhs.exp    = CR.Let (CR.Bind @thunkValRef (CR.Eval @cond.exp)) $
                        CR.Case (CR.Var $ CR.Tag @thunkValRef) [@t2.exp, @t1.exp]
        --lhs.offset = @lhs.offset + 1
        cond.forceEval = False
        --t1.level   = @lhs.level + 1
        t1.offset  = notRequired $ @lhs.offset + 1
        t2.offset  = notRequired $ @lhs.offset + 1
        t1.globalScope   = False
        t2.globalScope   = False
        cond.globalScope = False

{
expToSExp :: CR.Exp -> CR.SExp
expToSExp (CR.SExp se) = se
expToSExp _            = error "Exp not a SExp"

varToRef :: SourcePos -> Int -> Environment -> Var -> CR.Ref
varToRef pos currentLevel env x = case Map.lookup x env of
    Just (DeclLoc bindLevel offset) -> CR.Loc (currentLevel - bindLevel) offset
    Just (DeclGlob offset) -> CR.Glob offset
    Nothing -> error $ "Variable " ++ x ++ " not found (" ++ describeSourcePos pos ++ ")"

mkThunk :: CR.Exp -> CR.Exp
mkThunk = CR.Lam []

optForceEval :: Bool -> CR.Exp -> CR.Exp
optForceEval True x = CR.Eval x
optForceEval False x = x

notRequired :: a -> b
notRequired _ = error "has the program been passed to 'hm-to-anf'?"

}
