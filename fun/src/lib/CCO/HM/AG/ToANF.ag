-------------------------------------------------------------------------------
-- Attr grammar
-------------------------------------------------------------------------------
imports
{
import qualified CCO.Core.AG as CR
import qualified Data.Map as Map

import Debug.Trace
}

{
isANF :: Tm -> Bool
isANF (Tm _ t) = isANF_ t

isANF_ :: Tm_ -> Bool
isANF_ (Nat _) = True
isANF_ (Var _) = True
isANF_ _       = False

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

toSpecialName :: Int -> String
toSpecialName i = "$" ++ show i

introduceLets :: Tm -> Bindings -> Tm
introduceLets = foldr (\(x, pos, tm) body -> Tm pos (Let x tm body))

varOrBind :: Int -> SourcePos -> Tm -> (Tm,Bindings)
varOrBind varId _ t@(Tm _ (Var _)) = (t, [])
varOrBind varId bindPos t@(Tm pos t') = (Tm pos (Var name), [(name, bindPos, t)] ) where
  name = toSpecialName varId

type Bindings = [(String, SourcePos, Tm)]

}

attr Mod
  syn anf :: Mod

attr Tm Tm_ TmL AltL Alt
  chn counter                :: Int 
  syn bindings use {++} {[]} :: {Bindings}

attr TmL
  syn noLetTmL    :: TmL

attr Tm Tm_
  syn noLetTm     :: Tm

attr AltL Alt
  syn noLetAltL use {++} {[]} :: AltL

sem Mod
  | Mod loc.mainThunkRef = toSpecialName 0
        loc.mainThunk = Tm @tm.pos $ Let @mainThunkRef @tm.noLetTm (Tm @tm.pos $ Var @mainThunkRef)
        lhs.anf   = Mod @dataTypes.self (introduceLets @mainThunk @tm.bindings)
        tm.counter = 1

sem TmL
  | Cons  loc.unique :: uniqueref counter
          loc.anfBind  = varOrBind @unique @lhs.pos (introduceLets @hd.noLetTm @hd.bindings)
          lhs.bindings = snd @anfBind ++ @tl.bindings
          lhs.noLetTmL = fst @anfBind : @tl.noLetTmL
  | Nil   lhs.bindings = []
          lhs.noLetTmL = []

sem Tm_
  | Lam lhs.noLetTm  = Tm @lhs.pos $ Lam @x (introduceLets @t1.noLetTm @t1.bindings)
        lhs.bindings = []
  | Let lhs.noLetTm  = @t2.noLetTm
        lhs.bindings = [(@x, @lhs.pos, introduceLets @t1.noLetTm @t1.bindings)] ++ @t2.bindings
  | If  loc.uniqueCond :: uniqueref counter
        loc.uniqueThen :: uniqueref counter
        loc.uniqueElse :: uniqueref counter

        loc.anfBindCond = varOrBind @uniqueCond @lhs.pos (introduceLets @cond.noLetTm @cond.bindings)
        loc.anfBindThen = varOrBind @uniqueThen @lhs.pos (introduceLets @t1.noLetTm @t1.bindings)
        loc.anfBindElse = varOrBind @uniqueElse @lhs.pos (introduceLets @t2.noLetTm @t2.bindings)

        lhs.noLetTm  = Tm @lhs.pos $ If (fst @anfBindCond) (fst @anfBindThen) (fst @anfBindElse)
        lhs.bindings = snd @anfBindCond ++ snd @anfBindThen ++ snd @anfBindElse
  | Prim  loc.unique :: uniqueref counter
          loc.anfRef   = toSpecialName @unique
          lhs.noLetTm  = Tm @lhs.pos $ Var @anfRef
          lhs.bindings = @args.bindings ++ [(@anfRef, @lhs.pos, Tm @lhs.pos $ Prim @fn @args.noLetTmL)]
  | Var Nat lhs.noLetTm = Tm @lhs.pos @self
            lhs.bindings = []
  | App loc.uniqueFun :: uniqueref counter
        loc.uniqueArg :: uniqueref counter
        loc.anfBindFun = varOrBind @uniqueFun @lhs.pos (introduceLets @t1.noLetTm @t1.bindings)
        loc.anfBindArg = varOrBind @uniqueArg @lhs.pos (introduceLets @t2.noLetTm @t2.bindings)
        lhs.noLetTm  = Tm @lhs.pos $ App (fst @anfBindFun) (fst @anfBindArg)
        lhs.bindings = snd @anfBindFun ++ snd @anfBindArg

  | Case  loc.uniqueScrut :: uniqueref counter
          -- bind scrutinee to variable if it's not already a variable
          loc.anfBindScrut = varOrBind @uniqueScrut @lhs.pos (introduceLets @scrut.noLetTm @scrut.bindings)
          lhs.noLetTm  = Tm @lhs.pos $ Case (fst @anfBindScrut) @alts.noLetAltL
          lhs.bindings = snd @anfBindScrut ++ @alts.bindings

sem Alt
  -- alternatives introduces a new scope, where let bindings can be placed
  | Alt loc.uniqueAlt :: uniqueref counter
        lhs.noLetAltL = [ Alt @con @vars (introduceLets @tm.noLetTm @tm.bindings) ]
        lhs.bindings  = []