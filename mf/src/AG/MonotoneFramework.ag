imports
{
import Data.Maybe
import Data.List (find)
import qualified Data.Set as S
}

{
    
  
data Flow l = Flow { from :: l, to :: l }
  deriving (Eq, Ord, Show, Read)

data InterFlow l = InterFlow { fromOuter, toProc, fromProc, toOuter :: l }
  deriving (Eq, Ord, Show, Read)

type Flows = [Flow Label]
type InterFlows = [InterFlow Label]
}

attr Stat Proc Procs
    chn label :: Label

attr Program
    syn prog :: Program'

attr Proc Procs
    syn procs use {++} {[]} :: Procs'

attr Stat
    syn stat  :: Stat'
    
sem Program 
    | Program lhs.prog = Program' @procs.procs @stat.stat
              procs.label = 0
              stat.label = @procs.label
    
sem Stat
    | Skip       
      IfThenElse 
      While      
      IAssign    loc.labelgen :: uniqueref label
   
sem Stat
    | Skip       lhs.stat = Skip'       @loc.labelgen
    | IfThenElse lhs.stat = IfThenElse' @loc.labelgen @cond @stat1.stat @stat2.stat
    | While      lhs.stat = While'      @loc.labelgen @cond @stat.stat
    | IAssign    lhs.stat = IAssign'    @loc.labelgen @name @val
    | Seq        lhs.stat = Seq'        @stat1.stat @stat2.stat
    
    | Call       loc.lblCall :: uniqueref label
                 loc.lblReturn :: uniqueref label
                 lhs.stat = Call' @loc.lblCall @loc.lblReturn @name @params @out

sem Proc
    | Proc  loc.lblEntry :: uniqueref label
            loc.lblExit  :: uniqueref label
            lhs.procs     = [ Proc' @loc.lblEntry @loc.lblExit  @name @inp @out @stat.stat ]

  
attr Program' Stat'
    syn init   :: Label
    syn finals use {++} {[]} :: {[Label]}

attr Program' Stat' Procs' Proc'
    syn blocks    use {++} {[]} :: {[Block]}
    syn flow      use {++} {[]} :: {Flows}
    syn interflow use {++} {[]} :: {InterFlows} 
    
attr Stat' Procs' Proc'
    inh procs :: Procs'

attr Program' Stat' Exprs Expr IExpr BExpr
    syn globalVars  use {S.union} {S.empty} :: {S.Set Var}
    
{
data Block = BBlock         Label     BExpr
           | SkipBlock      Label 
           | IAssignBlock   Label Var IExpr
           | ProcBeginBlock Label
           | ProcEndBlock   Label
           | CallBlock      Label     Label Var Exprs Var
        -- | BAssignBlock Label Var {BExpr}
  deriving (Eq, Show)
}

sem Program'
    | Program' stat.procs = @procs.self
               procs.procs = @procs.self

sem Stat'
    | Skip'       lhs.init = @label
    | IfThenElse' lhs.init = @labelc
    | While'      lhs.init = @labelc
    | IAssign'    lhs.init = @label
    | Call'       lhs.init = @labelCall
    | Seq'        lhs.init = @stat1.init
    
sem Stat'
    | Skip'       lhs.finals = [@label]
    | IfThenElse' lhs.finals = @stat1.finals ++ @stat2.finals
    | While'      lhs.finals = [@labelc]
    | IAssign'    lhs.finals = [@label]
    | Call'       lhs.finals = [@labelReturn]
    | Seq'        lhs.finals = @stat2.finals
    
sem Stat'
    | Skip'       loc.blocks = [SkipBlock @label]
    | IfThenElse' loc.blocks = (BBlock @labelc @cond.self) : @stat1.blocks ++ @stat2.blocks
    | While'      loc.blocks = (BBlock @labelc @cond.self) : @stat.blocks
    | IAssign'    loc.blocks = [IAssignBlock @label @name @val.self]
    | Call'       loc.blocks = [CallBlock @labelCall @labelReturn @name @params.self @out]
    | Seq'        loc.blocks = @stat1.blocks ++ @stat2.blocks

sem Proc'
    | Proc'       loc.blocks = [ ProcBeginBlock @labelEntry, ProcEndBlock @labelExit ] ++ @stat.blocks
                  lhs.blocks = @blocks
                  lhs.labels = concatMap labelsFromBlock @blocks ++ @stat.labels

sem Stat'
    | Skip'       
      IfThenElse' 
      While'      
      IAssign'    
      Seq'        lhs.blocks = @blocks
    
sem Stat'
    | Skip' 
      IfThenElse' 
      While' 
      IAssign' 
      Seq'        lhs.labels = concatMap labelsFromBlock @blocks

sem Stat'
    | Skip'       lhs.flow = []
    | IfThenElse' lhs.flow = @stat1.flow ++ @stat2.flow ++ [Flow @labelc @stat1.init] 
                                ++ [Flow @labelc @stat2.init]
    | While'      lhs.flow = @stat.flow ++ [Flow @labelc @stat.init]
                                ++ zipWith Flow @stat.finals (repeat @labelc)
    | IAssign'    lhs.flow = []
    | Call'       loc.callee = findProc @name @lhs.procs
                  loc.lEntry    = labelEntry_Proc'_Proc' @callee
                  loc.lExit   = labelExit_Proc'_Proc' @callee
                  lhs.interflow = [ InterFlow @labelCall @lEntry @lExit @labelReturn ]
                  lhs.flow = [ Flow @labelCall @lEntry
                             , Flow @lExit @labelReturn ]
    | Seq'        lhs.flow = @stat1.flow ++ @stat2.flow ++ zipWith Flow @stat1.finals (repeat @stat2.init)
    
sem Proc'
    | Proc'       lhs.flow = Flow @labelEntry @stat.init : zipWith Flow @stat.finals (repeat @labelExit)
                              ++ @stat.flow
    

sem Stat'
    | IAssign' lhs.globalVars = S.singleton @name
    | Call'    lhs.globalVars = S.insert @out @params.globalVars   
    
sem IExpr
    | Var lhs.globalVars = S.singleton @name
    
--sem BExpr
--    | BVar lhs.globalVars = [@name]
        
{
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

reverseFlow :: Flows -> Flows
reverseFlow = map (\(Flow x y) -> (Flow y x))

labelsFromBlock :: Block -> [Label]
labelsFromBlock (BBlock       label _)   = [label]
labelsFromBlock (SkipBlock    label)     = [label]
labelsFromBlock (IAssignBlock label _ _) = [label]
labelsFromBlock (CallBlock lCall lRet _ _ _)   = [lCall, lRet]
labelsFromBlock (ProcBeginBlock label)   = [label]
labelsFromBlock (ProcEndBlock   label)   = [label]

labels :: [Block] -> [Label]
labels = concatMap labelsFromBlock

-- | Finds a procedure by its name.
findProc :: Var -> Procs' -> Proc'
findProc v ps = fromMaybe (error $ "procedure not found: " ++ v) $
  find (\p -> name_Proc'_Proc' p == v) ps

-- | Runs the attribute grammar for 'Program'.
toLabeledProgram :: Program -> Program'
toLabeledProgram prog = 
    prog_Syn_Program $ wrap_Program (sem_Program prog) Inh_Program

-- | calculate synthesized attributes for programs, yielding all the data required for monotone frameworks
programSyn :: Program' -> Syn_Program' 
programSyn prog = wrap_Program' (sem_Program' prog) Inh_Program'
}