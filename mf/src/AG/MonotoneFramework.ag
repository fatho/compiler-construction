attr Stat
    chn label :: Label

attr Program
    syn prog :: Program'
    
attr Stat
    syn stat :: Stat'
    
sem Program 
    | Program lhs.prog = Program' [] @stat.stat
              stat.label = 0
    
sem Stat
    | Skip       
      IfThenElse 
      While      
      IAssign    loc.label :: uniqueref label
   
sem Stat
    | Skip       lhs.stat = Skip'       @loc.label
    | IfThenElse lhs.stat = IfThenElse' @loc.label @cond @stat1.stat @stat2.stat
    | While      lhs.stat = While'      @loc.label @cond @stat.stat
    | IAssign    lhs.stat = IAssign'    @loc.label @name @val
    | Seq        lhs.stat = Seq' @stat1.stat @stat2.stat

attr Program' Stat'
    syn init   :: Label
    syn finals :: {[Label]}
    syn blocks :: {[Block]}
    syn labels :: {[Label]}
    syn flow   :: {[(Label, Label)]}
    
{
data Block = BBlock       Label     BExpr
           | SkipBlock    Label 
           | IAssignBlock Label Var IExpr
        -- | BAssignBlock Label Var {BExpr}  
}

sem Stat'
    | Skip'       lhs.init = @label
    | IfThenElse' lhs.init = @labelc
    | While'      lhs.init = @labelc
    | IAssign'    lhs.init = @label
    | Seq'        lhs.init = @stat1.init
    
sem Stat'
    | Skip'       lhs.finals = [@label]
    | IfThenElse' lhs.finals = @stat1.finals ++ @stat2.finals
    | While'      lhs.finals = [@labelc]
    | IAssign'    lhs.finals = [@label]
    | Seq'        lhs.finals = @stat1.finals
    
sem Stat'
    | Skip'       loc.blocks = [SkipBlock @label]
    | IfThenElse' loc.blocks = (BBlock @labelc @cond.self) : @stat1.blocks ++ @stat2.blocks
    | While'      loc.blocks = (BBlock @labelc @cond.self) : @stat.blocks
    | IAssign'    loc.blocks = [IAssignBlock @label @name @val.self]
    | Seq'        loc.blocks = @stat1.blocks ++ @stat2.blocks
    
sem Stat'
    | Skip'       
      IfThenElse' 
      While'      
      IAssign'    
      Seq'        lhs.blocks = @blocks
    
sem Stat'
    | Skip' 
      IfThenElse' 
      While' 
      IAssign' 
      Seq'        lhs.labels = map labelFromBlock @blocks
      
sem Stat'
    | Skip'       lhs.flow = []
    | IfThenElse' lhs.flow = @stat1.flow ++ @stat2.flow ++ [(@labelc, @stat1.init)] ++ [(@labelc, @stat2.init)]
    | While'      lhs.flow = @stat.flow ++ [(@labelc, @stat.init)] ++ zip @stat.finals (repeat @labelc)
    | IAssign'    lhs.flow = []
    | Seq'        lhs.flow = @stat1.flow ++ @stat2.flow ++ zip @stat1.finals (repeat @stat2.init)
    
{
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

labelFromBlock :: Block -> Label
labelFromBlock (BBlock       label _)   = label
labelFromBlock (SkipBlock    label)     = label
labelFromBlock (IAssignBlock label _ _) = label
}