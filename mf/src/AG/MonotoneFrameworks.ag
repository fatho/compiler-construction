imports
{
import Data.Maybe
import Data.List (find)
import qualified Data.Set as S
}

{
data Flow l = Flow { from :: l, to :: l }
  deriving (Eq, Ord, Show, Read)

data InterFlow l = InterFlow { fromOuter, toProc, fromProc, toOuter :: l }
  deriving (Eq, Ord, Show, Read)

-- | The call flow part of an interflow. 
callFlow :: InterFlow l -> Flow l
callFlow ifl = Flow (fromOuter ifl) (toProc ifl)
  
-- | The return flow part of an interflow.
returnFlow :: InterFlow l -> Flow l
returnFlow ifl = Flow (fromProc ifl) (toOuter ifl)

-- | Reverse the flow direction
reverseFlow :: Flows -> Flows
reverseFlow = map (\(Flow x y) -> Flow y x)

-- | Reverse the inter-flow direction
reverseInterFlow :: InterFlows -> InterFlows
reverseInterFlow = map (\(InterFlow a b c d) -> InterFlow d c b a)

type Flows = [Flow Label]
type InterFlows = [InterFlow Label]
}
  
attr Program' Stat'
    syn init   :: Label
    syn finals use {++} {[]} :: {[Label]}

attr Program' Stat' Procs' Proc'
    syn blocks    use {++} {[]} :: {[Block]}
    syn flow      use {++} {[]} :: {Flows}
    syn interflow use {++} {[]} :: {InterFlows} 
    
attr Stat' Procs' Proc'
    inh procs :: Procs'

attr Program'
    syn globalVars :: {S.Set Var}

attr Procs' Proc'
    inh globalVars :: {S.Set Var}

attr Proc'
    syn localVars  :: {S.Set Var} 

attr Stat' Exprs Expr IExpr BExpr
    syn vars use {S.union} {S.empty} :: {S.Set Var}

{
data Block = BBlock         Label     BExpr
           | SkipBlock      Label 
           | IAssignBlock   Label Var IExpr
           | ProcBeginBlock Label
           | ProcEndBlock   Label
           | CallBlock      Label     Label Var Exprs Var
        -- | BAssignBlock Label Var {BExpr}
  deriving (Eq, Show)
}

sem Program'
    | Program' stat. procs      = @procs.self
               procs.procs      = @procs.self
               procs.globalVars = @stat.vars
               lhs  .globalVars = @stat.vars

sem Proc'
    -- all variables used in a procedure that are not global variables
    -- or 
    | Proc'     loc.argVars   = S.fromList (@out : @inp)
                lhs.localVars  = S.union (@stat.vars S.\\ @lhs.globalVars) @argVars 

sem Stat'
    | Skip'       lhs.init = @label
    | IfThenElse' lhs.init = @labelc
    | While'      lhs.init = @labelc
    | IAssign'    lhs.init = @label
    | Call'       lhs.init = @labelCall
    | Seq'        lhs.init = @stat1.init
    
sem Stat'
    | Skip'       lhs.finals = [@label]
    | IfThenElse' lhs.finals = @stat1.finals ++ @stat2.finals
    | While'      lhs.finals = [@labelc]
    | IAssign'    lhs.finals = [@label]
    | Call'       lhs.finals = [@labelReturn]
    | Seq'        lhs.finals = @stat2.finals
    
sem Stat'
    | Skip'       lhs.blocks = [SkipBlock @label]
    | IfThenElse' lhs.blocks = (BBlock @labelc @cond.self) : @stat1.blocks ++ @stat2.blocks
    | While'      lhs.blocks = (BBlock @labelc @cond.self) : @stat.blocks
    | IAssign'    lhs.blocks = [IAssignBlock @label @name @val.self]
    | Call'       lhs.blocks = [CallBlock @labelCall @labelReturn @name @params.self @out]
    | Seq'        lhs.blocks = @stat1.blocks ++ @stat2.blocks

sem Proc'
    | Proc'       lhs.blocks = [ ProcBeginBlock @labelEntry, ProcEndBlock @labelExit ] ++ @stat.blocks

sem Stat'
    | Skip'       lhs.flow = []
    | IfThenElse' lhs.flow = @stat1.flow ++ @stat2.flow ++ [Flow @labelc @stat1.init] 
                                ++ [Flow @labelc @stat2.init]
    | While'      lhs.flow = @stat.flow ++ [Flow @labelc @stat.init]
                                ++ zipWith Flow @stat.finals (repeat @labelc)
    | IAssign'    lhs.flow = []
    | Call'       loc.callee = findProc @name @lhs.procs
                  loc.lEntry    = labelEntry_Proc'_Proc' @callee
                  loc.lExit   = labelExit_Proc'_Proc' @callee
                  lhs.interflow = [ InterFlow @labelCall @lEntry @lExit @labelReturn ]
                  lhs.flow = [ Flow @labelCall @lEntry
                             , Flow @lExit @labelReturn ]
    | Seq'        lhs.flow = @stat1.flow ++ @stat2.flow ++ zipWith Flow @stat1.finals (repeat @stat2.init)
    
sem Proc'
    | Proc'       lhs.flow = Flow @labelEntry @stat.init : zipWith Flow @stat.finals (repeat @labelExit)
                              ++ @stat.flow
    

sem Stat'
    | IAssign' lhs.vars = S.singleton @name
    | Call'    lhs.vars = S.insert @out @params.vars   
    
sem IExpr
    | Var lhs.vars = S.singleton @name
    
sem BExpr
    | BVar lhs.vars = S.singleton @name
        
{
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

labelsFromBlock :: Block -> [Label]
labelsFromBlock (BBlock       label _)   = [label]
labelsFromBlock (SkipBlock    label)     = [label]
labelsFromBlock (IAssignBlock label _ _) = [label]
labelsFromBlock (CallBlock lCall lRet _ _ _)   = [lCall, lRet]
labelsFromBlock (ProcBeginBlock label)   = [label]
labelsFromBlock (ProcEndBlock   label)   = [label]

labels :: [Block] -> [Label]
labels = concatMap labelsFromBlock

-- | Finds a procedure by its name.
findProc :: Var -> Procs' -> Proc'
findProc v ps = fromMaybe (error $ "procedure not found: " ++ v) $
  find (\p -> name_Proc'_Proc' p == v) ps

}