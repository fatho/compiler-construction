imports
{
import qualified Data.Map as M
import qualified Data.Maybe as Maybe
import qualified Data.List as L
import qualified Data.Set as S

import CCO.Printing
}

{
type Label = Int
type Var = String
}

data Program
  | Program   procs :: Procs
              stat  :: Stat
  deriving Program : Show

data Program'
  | Program'  procs :: Procs'
              stat :: Stat'
  deriving Program' : Show

data Proc
  | Proc          name :: Var  inp :: {[String]}  out :: String   stat :: Stat
deriving Proc : Show

data Proc'
  | Proc'         labelEntry :: Label  labelExit :: Label    name :: Var  inp :: {[String]}  out :: String   stat :: Stat'
deriving Proc' : Show

data Stat
  | Skip
  | IfThenElse    cond  :: {BExpr}      stat1  :: Stat       stat2 :: Stat
  | While         cond  :: {BExpr}      stat   :: Stat
  | Call          name  :: Var          params :: {Exprs}    out :: String
  | IAssign       name  :: Var          val    :: {IExpr}
  | BAssign       name  :: Var          val    :: {BExpr}
  | Seq           stat1 :: Stat         stat2  :: Stat
  | Malloc        name  :: Var          size   :: {IExpr}
  | Free          ptr   :: {IExpr}
  | RefAssign     ptr   :: {IExpr}      val    :: {IExpr}
  | Continue
  | Break
deriving Stat : Show

data Stat'
  | Skip'          label :: Label
  | IfThenElse'    labelc :: Label       cond  :: BExpr      stat1  :: Stat'     stat2 :: Stat'
  | While'         labelc :: Label       cond  :: BExpr      stat   :: Stat'
  | Call'          labelCall :: Label    labelReturn :: Label  name :: Var     params :: Exprs    out :: Var
  | IAssign'       label :: Label        name :: Var     val    :: IExpr
  | BAssign'       label :: Label        name :: Var     val    :: BExpr
  | Seq'           stat1 :: Stat'        stat2  :: Stat'
  | Malloc'        label :: Label        name :: Var     size   :: IExpr
  | Free'          label :: Label        ptr   :: IExpr
  | RefAssign'     label :: Label        ptr   :: IExpr      val :: IExpr
  | Continue'      label :: Label
  | Break'         label :: Label
deriving Stat' : Show

data IExpr 
  | IConst        val  :: Int
  | Var           name :: Var
  | Plus          left :: IExpr       right :: IExpr
  | Minus         left :: IExpr       right :: IExpr
  | Times         left :: IExpr       right :: IExpr
  | Divide        left :: IExpr       right :: IExpr
  | Deref         ptr  :: IExpr
deriving IExpr : Eq, Show

data BExpr
  | BConst        val  :: Bool
  | BVar          name :: Var
  | LessThan      left :: IExpr       right :: IExpr
  | GreaterThan   left :: IExpr       right :: IExpr
  | LessEqual     left :: IExpr       right :: IExpr
  | GreaterEqual  left :: IExpr       right :: IExpr
  | IEqual        left :: IExpr       right :: IExpr
  | BEqual        left :: BExpr       right :: BExpr
  | And           left :: BExpr       right :: BExpr
  | Or            left :: BExpr       right :: BExpr
  | Not           val  :: BExpr
deriving BExpr : Eq, Show


data Expr | B BExpr
          | I IExpr
deriving Expr : Eq, Show

data Code | CBExpr   BExpr
          | CIExpr   IExpr
          | CStat    Stat'
          | CProc    Proc'
          | CProgram Program'

type Procs = [Proc]
type Procs' = [Proc']
type Exprs = [Expr]

{
varSetIExpr :: IExpr -> S.Set Var -> S.Set Var
varSetIExpr (IConst v)   vs = vs
varSetIExpr (Var name)   vs = S.insert name vs
varSetIExpr (Plus l r)   vs = varSetIExpr l vs `S.union` varSetIExpr r vs 
varSetIExpr (Minus l r)  vs = varSetIExpr l vs `S.union` varSetIExpr r vs 
varSetIExpr (Times l r)  vs = varSetIExpr l vs `S.union` varSetIExpr r vs 
varSetIExpr (Divide l r) vs = varSetIExpr l vs `S.union` varSetIExpr r vs 
varSetIExpr (Deref ptr)  vs = error "Deref not implemented"

varSetBExpr :: BExpr -> S.Set Var -> S.Set Var
varSetBExpr (BConst v)         vs = vs        
varSetBExpr (BVar name)        vs = S.insert name vs        
varSetBExpr (LessThan l r)     vs = varSetIExpr l vs `S.union` varSetIExpr r vs            
varSetBExpr (GreaterThan l r)  vs = varSetIExpr l vs `S.union` varSetIExpr r vs            
varSetBExpr (LessEqual l r)    vs = varSetIExpr l vs `S.union` varSetIExpr r vs
varSetBExpr (GreaterEqual l r) vs = varSetIExpr l vs `S.union` varSetIExpr r vs            
varSetBExpr (IEqual l r)       vs = varSetIExpr l vs `S.union` varSetIExpr r vs        
varSetBExpr (BEqual l r)       vs = varSetBExpr l vs `S.union` varSetBExpr r vs     
varSetBExpr (And l r)          vs = varSetBExpr l vs `S.union` varSetBExpr r vs     
varSetBExpr (Or l r)           vs = varSetBExpr l vs `S.union` varSetBExpr r vs 
varSetBExpr (Not x)            vs = varSetBExpr x vs

-- | Evaluates an 'IExpr' in an arbitrary numerical context. 
evalIExpr :: (Integral a) => IExpr -> (Var -> a) -> a
evalIExpr e env = go e where
  go (IConst v) = fromIntegral v
  go (Var name) = env name
  go (Plus l r) = go l + go r
  go (Minus l r) = go l - go r
  go (Times l r) = go l * go r
  go (Divide l r) = go l `div` go r
  go (Deref ptr) = error "Deref not implemented"
  
instance Printable Program where
  pp = showable
  
instance Printable Program' where
  pp = showable
}